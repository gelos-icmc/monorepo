# Action CI
# Roda todos os `checks` do flake
# 
# Você pode rodar eles localmente usando `nix flake check .`

name: "CI"
on:
  push:
    branches:
      - main
  pull_request:
  merge_group:
jobs:
  # Pula a CI do merge queue se for idêntica a uma CI de PR já executada
  skip-check:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.skip-check.outputs.skip-check }}
    steps:
      - uses: cariad-tech/merge-queue-ci-skipper@1032489e59437862c90a08a2c92809c903883772
        id: skip-check

  flake-check:
    needs: skip-check
    if: needs.skip-check.outputs.skip != 'true'
    strategy:
      fail-fast: false
      matrix:
        platform:
          - system: x86_64-linux
            runner: ubuntu-24.04
          - system: aarch64-linux
            runner: ubuntu-24.04-arm
    name: flake-check (${{ matrix.platform.system }})
    runs-on: ${{ matrix.platform.runner }}
    steps:
      - uses: actions/checkout@v3
      - uses: wimpysworld/nothing-but-nix@bfeb418c0047173b701321078aca83b342e77ec2
        with:
          nix-permission-edict: true
      - uses: nixbuild/nix-quick-install-action@v30
      - uses: nix-community/cache-nix-action@v6
        with:
          primary-key: ${{ matrix.platform.system }}
      - uses: cachix/cachix-action@v14
        with:
          name: gelos-icmc
          authToken: '${{ secrets.CACHIX_KEY }}'
      - run: nix flake check

  required: # group all required workflows into one to avoid reconfiguring this in Actions settings
    needs:
      - flake-check
    if: ${{ always() && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    steps:
      - run: ${{ contains(needs.*.result, 'failure') && 'false' || 'true' }}
